{"version":3,"file":"index-browser-esm.min.js","sources":["../node_modules/.pnpm/jsep@1.3.8/node_modules/jsep/dist/jsep.js","../node_modules/.pnpm/@jsep-plugin+regex@1.0.3_jsep@1.3.8/node_modules/@jsep-plugin/regex/dist/index.js","../src/jsonpath.js","../src/jsonpath-browser.js"],"sourcesContent":["/**\n * @implements {IHooks}\n */\nclass Hooks {\n\t/**\n\t * @callback HookCallback\n\t * @this {*|Jsep} this\n\t * @param {Jsep} env\n\t * @returns: void\n\t */\n\t/**\n\t * Adds the given callback to the list of callbacks for the given hook.\n\t *\n\t * The callback will be invoked when the hook it is registered for is run.\n\t *\n\t * One callback function can be registered to multiple hooks and the same hook multiple times.\n\t *\n\t * @param {string|object} name The name of the hook, or an object of callbacks keyed by name\n\t * @param {HookCallback|boolean} callback The callback function which is given environment variables.\n\t * @param {?boolean} [first=false] Will add the hook to the top of the list (defaults to the bottom)\n\t * @public\n\t */\n\tadd(name, callback, first) {\n\t\tif (typeof arguments[0] != 'string') {\n\t\t\t// Multiple hook callbacks, keyed by name\n\t\t\tfor (let name in arguments[0]) {\n\t\t\t\tthis.add(name, arguments[0][name], arguments[1]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t(Array.isArray(name) ? name : [name]).forEach(function (name) {\n\t\t\t\tthis[name] = this[name] || [];\n\n\t\t\t\tif (callback) {\n\t\t\t\t\tthis[name][first ? 'unshift' : 'push'](callback);\n\t\t\t\t}\n\t\t\t}, this);\n\t\t}\n\t}\n\n\t/**\n\t * Runs a hook invoking all registered callbacks with the given environment variables.\n\t *\n\t * Callbacks will be invoked synchronously and in the order in which they were registered.\n\t *\n\t * @param {string} name The name of the hook.\n\t * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\n\t * @public\n\t */\n\trun(name, env) {\n\t\tthis[name] = this[name] || [];\n\t\tthis[name].forEach(function (callback) {\n\t\t\tcallback.call(env && env.context ? env.context : env, env);\n\t\t});\n\t}\n}\n\n/**\n * @implements {IPlugins}\n */\nclass Plugins {\n\tconstructor(jsep) {\n\t\tthis.jsep = jsep;\n\t\tthis.registered = {};\n\t}\n\n\t/**\n\t * @callback PluginSetup\n\t * @this {Jsep} jsep\n\t * @returns: void\n\t */\n\t/**\n\t * Adds the given plugin(s) to the registry\n\t *\n\t * @param {object} plugins\n\t * @param {string} plugins.name The name of the plugin\n\t * @param {PluginSetup} plugins.init The init function\n\t * @public\n\t */\n\tregister(...plugins) {\n\t\tplugins.forEach((plugin) => {\n\t\t\tif (typeof plugin !== 'object' || !plugin.name || !plugin.init) {\n\t\t\t\tthrow new Error('Invalid JSEP plugin format');\n\t\t\t}\n\t\t\tif (this.registered[plugin.name]) {\n\t\t\t\t// already registered. Ignore.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tplugin.init(this.jsep);\n\t\t\tthis.registered[plugin.name] = plugin;\n\t\t});\n\t}\n}\n\n//     JavaScript Expression Parser (JSEP) 1.3.8\n\nclass Jsep {\n\t/**\n\t * @returns {string}\n\t */\n\tstatic get version() {\n\t\t// To be filled in by the template\n\t\treturn '1.3.8';\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\tstatic toString() {\n\t\treturn 'JavaScript Expression Parser (JSEP) v' + Jsep.version;\n\t};\n\n\t// ==================== CONFIG ================================\n\t/**\n\t * @method addUnaryOp\n\t * @param {string} op_name The name of the unary op to add\n\t * @returns {Jsep}\n\t */\n\tstatic addUnaryOp(op_name) {\n\t\tJsep.max_unop_len = Math.max(op_name.length, Jsep.max_unop_len);\n\t\tJsep.unary_ops[op_name] = 1;\n\t\treturn Jsep;\n\t}\n\n\t/**\n\t * @method jsep.addBinaryOp\n\t * @param {string} op_name The name of the binary op to add\n\t * @param {number} precedence The precedence of the binary op (can be a float). Higher number = higher precedence\n\t * @param {boolean} [isRightAssociative=false] whether operator is right-associative\n\t * @returns {Jsep}\n\t */\n\tstatic addBinaryOp(op_name, precedence, isRightAssociative) {\n\t\tJsep.max_binop_len = Math.max(op_name.length, Jsep.max_binop_len);\n\t\tJsep.binary_ops[op_name] = precedence;\n\t\tif (isRightAssociative) {\n\t\t\tJsep.right_associative.add(op_name);\n\t\t}\n\t\telse {\n\t\t\tJsep.right_associative.delete(op_name);\n\t\t}\n\t\treturn Jsep;\n\t}\n\n\t/**\n\t * @method addIdentifierChar\n\t * @param {string} char The additional character to treat as a valid part of an identifier\n\t * @returns {Jsep}\n\t */\n\tstatic addIdentifierChar(char) {\n\t\tJsep.additional_identifier_chars.add(char);\n\t\treturn Jsep;\n\t}\n\n\t/**\n\t * @method addLiteral\n\t * @param {string} literal_name The name of the literal to add\n\t * @param {*} literal_value The value of the literal\n\t * @returns {Jsep}\n\t */\n\tstatic addLiteral(literal_name, literal_value) {\n\t\tJsep.literals[literal_name] = literal_value;\n\t\treturn Jsep;\n\t}\n\n\t/**\n\t * @method removeUnaryOp\n\t * @param {string} op_name The name of the unary op to remove\n\t * @returns {Jsep}\n\t */\n\tstatic removeUnaryOp(op_name) {\n\t\tdelete Jsep.unary_ops[op_name];\n\t\tif (op_name.length === Jsep.max_unop_len) {\n\t\t\tJsep.max_unop_len = Jsep.getMaxKeyLen(Jsep.unary_ops);\n\t\t}\n\t\treturn Jsep;\n\t}\n\n\t/**\n\t * @method removeAllUnaryOps\n\t * @returns {Jsep}\n\t */\n\tstatic removeAllUnaryOps() {\n\t\tJsep.unary_ops = {};\n\t\tJsep.max_unop_len = 0;\n\n\t\treturn Jsep;\n\t}\n\n\t/**\n\t * @method removeIdentifierChar\n\t * @param {string} char The additional character to stop treating as a valid part of an identifier\n\t * @returns {Jsep}\n\t */\n\tstatic removeIdentifierChar(char) {\n\t\tJsep.additional_identifier_chars.delete(char);\n\t\treturn Jsep;\n\t}\n\n\t/**\n\t * @method removeBinaryOp\n\t * @param {string} op_name The name of the binary op to remove\n\t * @returns {Jsep}\n\t */\n\tstatic removeBinaryOp(op_name) {\n\t\tdelete Jsep.binary_ops[op_name];\n\n\t\tif (op_name.length === Jsep.max_binop_len) {\n\t\t\tJsep.max_binop_len = Jsep.getMaxKeyLen(Jsep.binary_ops);\n\t\t}\n\t\tJsep.right_associative.delete(op_name);\n\n\t\treturn Jsep;\n\t}\n\n\t/**\n\t * @method removeAllBinaryOps\n\t * @returns {Jsep}\n\t */\n\tstatic removeAllBinaryOps() {\n\t\tJsep.binary_ops = {};\n\t\tJsep.max_binop_len = 0;\n\n\t\treturn Jsep;\n\t}\n\n\t/**\n\t * @method removeLiteral\n\t * @param {string} literal_name The name of the literal to remove\n\t * @returns {Jsep}\n\t */\n\tstatic removeLiteral(literal_name) {\n\t\tdelete Jsep.literals[literal_name];\n\t\treturn Jsep;\n\t}\n\n\t/**\n\t * @method removeAllLiterals\n\t * @returns {Jsep}\n\t */\n\tstatic removeAllLiterals() {\n\t\tJsep.literals = {};\n\n\t\treturn Jsep;\n\t}\n\t// ==================== END CONFIG ============================\n\n\n\t/**\n\t * @returns {string}\n\t */\n\tget char() {\n\t\treturn this.expr.charAt(this.index);\n\t}\n\n\t/**\n\t * @returns {number}\n\t */\n\tget code() {\n\t\treturn this.expr.charCodeAt(this.index);\n\t};\n\n\n\t/**\n\t * @param {string} expr a string with the passed in express\n\t * @returns Jsep\n\t */\n\tconstructor(expr) {\n\t\t// `index` stores the character number we are currently at\n\t\t// All of the gobbles below will modify `index` as we move along\n\t\tthis.expr = expr;\n\t\tthis.index = 0;\n\t}\n\n\t/**\n\t * static top-level parser\n\t * @returns {jsep.Expression}\n\t */\n\tstatic parse(expr) {\n\t\treturn (new Jsep(expr)).parse();\n\t}\n\n\t/**\n\t * Get the longest key length of any object\n\t * @param {object} obj\n\t * @returns {number}\n\t */\n\tstatic getMaxKeyLen(obj) {\n\t\treturn Math.max(0, ...Object.keys(obj).map(k => k.length));\n\t}\n\n\t/**\n\t * `ch` is a character code in the next three functions\n\t * @param {number} ch\n\t * @returns {boolean}\n\t */\n\tstatic isDecimalDigit(ch) {\n\t\treturn (ch >= 48 && ch <= 57); // 0...9\n\t}\n\n\t/**\n\t * Returns the precedence of a binary operator or `0` if it isn't a binary operator. Can be float.\n\t * @param {string} op_val\n\t * @returns {number}\n\t */\n\tstatic binaryPrecedence(op_val) {\n\t\treturn Jsep.binary_ops[op_val] || 0;\n\t}\n\n\t/**\n\t * Looks for start of identifier\n\t * @param {number} ch\n\t * @returns {boolean}\n\t */\n\tstatic isIdentifierStart(ch) {\n\t\treturn  (ch >= 65 && ch <= 90) || // A...Z\n\t\t\t(ch >= 97 && ch <= 122) || // a...z\n\t\t\t(ch >= 128 && !Jsep.binary_ops[String.fromCharCode(ch)]) || // any non-ASCII that is not an operator\n\t\t\t(Jsep.additional_identifier_chars.has(String.fromCharCode(ch))); // additional characters\n\t}\n\n\t/**\n\t * @param {number} ch\n\t * @returns {boolean}\n\t */\n\tstatic isIdentifierPart(ch) {\n\t\treturn Jsep.isIdentifierStart(ch) || Jsep.isDecimalDigit(ch);\n\t}\n\n\t/**\n\t * throw error at index of the expression\n\t * @param {string} message\n\t * @throws\n\t */\n\tthrowError(message) {\n\t\tconst error = new Error(message + ' at character ' + this.index);\n\t\terror.index = this.index;\n\t\terror.description = message;\n\t\tthrow error;\n\t}\n\n\t/**\n\t * Run a given hook\n\t * @param {string} name\n\t * @param {jsep.Expression|false} [node]\n\t * @returns {?jsep.Expression}\n\t */\n\trunHook(name, node) {\n\t\tif (Jsep.hooks[name]) {\n\t\t\tconst env = { context: this, node };\n\t\t\tJsep.hooks.run(name, env);\n\t\t\treturn env.node;\n\t\t}\n\t\treturn node;\n\t}\n\n\t/**\n\t * Runs a given hook until one returns a node\n\t * @param {string} name\n\t * @returns {?jsep.Expression}\n\t */\n\tsearchHook(name) {\n\t\tif (Jsep.hooks[name]) {\n\t\t\tconst env = { context: this };\n\t\t\tJsep.hooks[name].find(function (callback) {\n\t\t\t\tcallback.call(env.context, env);\n\t\t\t\treturn env.node;\n\t\t\t});\n\t\t\treturn env.node;\n\t\t}\n\t}\n\n\t/**\n\t * Push `index` up to the next non-space character\n\t */\n\tgobbleSpaces() {\n\t\tlet ch = this.code;\n\t\t// Whitespace\n\t\twhile (ch === Jsep.SPACE_CODE\n\t\t|| ch === Jsep.TAB_CODE\n\t\t|| ch === Jsep.LF_CODE\n\t\t|| ch === Jsep.CR_CODE) {\n\t\t\tch = this.expr.charCodeAt(++this.index);\n\t\t}\n\t\tthis.runHook('gobble-spaces');\n\t}\n\n\t/**\n\t * Top-level method to parse all expressions and returns compound or single node\n\t * @returns {jsep.Expression}\n\t */\n\tparse() {\n\t\tthis.runHook('before-all');\n\t\tconst nodes = this.gobbleExpressions();\n\n\t\t// If there's only one expression just try returning the expression\n\t\tconst node = nodes.length === 1\n\t\t  ? nodes[0]\n\t\t\t: {\n\t\t\t\ttype: Jsep.COMPOUND,\n\t\t\t\tbody: nodes\n\t\t\t};\n\t\treturn this.runHook('after-all', node);\n\t}\n\n\t/**\n\t * top-level parser (but can be reused within as well)\n\t * @param {number} [untilICode]\n\t * @returns {jsep.Expression[]}\n\t */\n\tgobbleExpressions(untilICode) {\n\t\tlet nodes = [], ch_i, node;\n\n\t\twhile (this.index < this.expr.length) {\n\t\t\tch_i = this.code;\n\n\t\t\t// Expressions can be separated by semicolons, commas, or just inferred without any\n\t\t\t// separators\n\t\t\tif (ch_i === Jsep.SEMCOL_CODE || ch_i === Jsep.COMMA_CODE) {\n\t\t\t\tthis.index++; // ignore separators\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Try to gobble each expression individually\n\t\t\t\tif (node = this.gobbleExpression()) {\n\t\t\t\t\tnodes.push(node);\n\t\t\t\t\t// If we weren't able to find a binary expression and are out of room, then\n\t\t\t\t\t// the expression passed in probably has too much\n\t\t\t\t}\n\t\t\t\telse if (this.index < this.expr.length) {\n\t\t\t\t\tif (ch_i === untilICode) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tthis.throwError('Unexpected \"' + this.char + '\"');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn nodes;\n\t}\n\n\t/**\n\t * The main parsing function.\n\t * @returns {?jsep.Expression}\n\t */\n\tgobbleExpression() {\n\t\tconst node = this.searchHook('gobble-expression') || this.gobbleBinaryExpression();\n\t\tthis.gobbleSpaces();\n\n\t\treturn this.runHook('after-expression', node);\n\t}\n\n\t/**\n\t * Search for the operation portion of the string (e.g. `+`, `===`)\n\t * Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)\n\t * and move down from 3 to 2 to 1 character until a matching binary operation is found\n\t * then, return that binary operation\n\t * @returns {string|boolean}\n\t */\n\tgobbleBinaryOp() {\n\t\tthis.gobbleSpaces();\n\t\tlet to_check = this.expr.substr(this.index, Jsep.max_binop_len);\n\t\tlet tc_len = to_check.length;\n\n\t\twhile (tc_len > 0) {\n\t\t\t// Don't accept a binary op when it is an identifier.\n\t\t\t// Binary ops that start with a identifier-valid character must be followed\n\t\t\t// by a non identifier-part valid character\n\t\t\tif (Jsep.binary_ops.hasOwnProperty(to_check) && (\n\t\t\t\t!Jsep.isIdentifierStart(this.code) ||\n\t\t\t\t(this.index + to_check.length < this.expr.length && !Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))\n\t\t\t)) {\n\t\t\t\tthis.index += tc_len;\n\t\t\t\treturn to_check;\n\t\t\t}\n\t\t\tto_check = to_check.substr(0, --tc_len);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * This function is responsible for gobbling an individual expression,\n\t * e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`\n\t * @returns {?jsep.BinaryExpression}\n\t */\n\tgobbleBinaryExpression() {\n\t\tlet node, biop, prec, stack, biop_info, left, right, i, cur_biop;\n\n\t\t// First, try to get the leftmost thing\n\t\t// Then, check to see if there's a binary operator operating on that leftmost thing\n\t\t// Don't gobbleBinaryOp without a left-hand-side\n\t\tleft = this.gobbleToken();\n\t\tif (!left) {\n\t\t\treturn left;\n\t\t}\n\t\tbiop = this.gobbleBinaryOp();\n\n\t\t// If there wasn't a binary operator, just return the leftmost node\n\t\tif (!biop) {\n\t\t\treturn left;\n\t\t}\n\n\t\t// Otherwise, we need to start a stack to properly place the binary operations in their\n\t\t// precedence structure\n\t\tbiop_info = { value: biop, prec: Jsep.binaryPrecedence(biop), right_a: Jsep.right_associative.has(biop) };\n\n\t\tright = this.gobbleToken();\n\n\t\tif (!right) {\n\t\t\tthis.throwError(\"Expected expression after \" + biop);\n\t\t}\n\n\t\tstack = [left, biop_info, right];\n\n\t\t// Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)\n\t\twhile ((biop = this.gobbleBinaryOp())) {\n\t\t\tprec = Jsep.binaryPrecedence(biop);\n\n\t\t\tif (prec === 0) {\n\t\t\t\tthis.index -= biop.length;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbiop_info = { value: biop, prec, right_a: Jsep.right_associative.has(biop) };\n\n\t\t\tcur_biop = biop;\n\n\t\t\t// Reduce: make a binary expression from the three topmost entries.\n\t\t\tconst comparePrev = prev => biop_info.right_a && prev.right_a\n\t\t\t\t? prec > prev.prec\n\t\t\t\t: prec <= prev.prec;\n\t\t\twhile ((stack.length > 2) && comparePrev(stack[stack.length - 2])) {\n\t\t\t\tright = stack.pop();\n\t\t\t\tbiop = stack.pop().value;\n\t\t\t\tleft = stack.pop();\n\t\t\t\tnode = {\n\t\t\t\t\ttype: Jsep.BINARY_EXP,\n\t\t\t\t\toperator: biop,\n\t\t\t\t\tleft,\n\t\t\t\t\tright\n\t\t\t\t};\n\t\t\t\tstack.push(node);\n\t\t\t}\n\n\t\t\tnode = this.gobbleToken();\n\n\t\t\tif (!node) {\n\t\t\t\tthis.throwError(\"Expected expression after \" + cur_biop);\n\t\t\t}\n\n\t\t\tstack.push(biop_info, node);\n\t\t}\n\n\t\ti = stack.length - 1;\n\t\tnode = stack[i];\n\n\t\twhile (i > 1) {\n\t\t\tnode = {\n\t\t\t\ttype: Jsep.BINARY_EXP,\n\t\t\t\toperator: stack[i - 1].value,\n\t\t\t\tleft: stack[i - 2],\n\t\t\t\tright: node\n\t\t\t};\n\t\t\ti -= 2;\n\t\t}\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * An individual part of a binary expression:\n\t * e.g. `foo.bar(baz)`, `1`, `\"abc\"`, `(a % 2)` (because it's in parenthesis)\n\t * @returns {boolean|jsep.Expression}\n\t */\n\tgobbleToken() {\n\t\tlet ch, to_check, tc_len, node;\n\n\t\tthis.gobbleSpaces();\n\t\tnode = this.searchHook('gobble-token');\n\t\tif (node) {\n\t\t\treturn this.runHook('after-token', node);\n\t\t}\n\n\t\tch = this.code;\n\n\t\tif (Jsep.isDecimalDigit(ch) || ch === Jsep.PERIOD_CODE) {\n\t\t\t// Char code 46 is a dot `.` which can start off a numeric literal\n\t\t\treturn this.gobbleNumericLiteral();\n\t\t}\n\n\t\tif (ch === Jsep.SQUOTE_CODE || ch === Jsep.DQUOTE_CODE) {\n\t\t\t// Single or double quotes\n\t\t\tnode = this.gobbleStringLiteral();\n\t\t}\n\t\telse if (ch === Jsep.OBRACK_CODE) {\n\t\t\tnode = this.gobbleArray();\n\t\t}\n\t\telse {\n\t\t\tto_check = this.expr.substr(this.index, Jsep.max_unop_len);\n\t\t\ttc_len = to_check.length;\n\n\t\t\twhile (tc_len > 0) {\n\t\t\t\t// Don't accept an unary op when it is an identifier.\n\t\t\t\t// Unary ops that start with a identifier-valid character must be followed\n\t\t\t\t// by a non identifier-part valid character\n\t\t\t\tif (Jsep.unary_ops.hasOwnProperty(to_check) && (\n\t\t\t\t\t!Jsep.isIdentifierStart(this.code) ||\n\t\t\t\t\t(this.index + to_check.length < this.expr.length && !Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))\n\t\t\t\t)) {\n\t\t\t\t\tthis.index += tc_len;\n\t\t\t\t\tconst argument = this.gobbleToken();\n\t\t\t\t\tif (!argument) {\n\t\t\t\t\t\tthis.throwError('missing unaryOp argument');\n\t\t\t\t\t}\n\t\t\t\t\treturn this.runHook('after-token', {\n\t\t\t\t\t\ttype: Jsep.UNARY_EXP,\n\t\t\t\t\t\toperator: to_check,\n\t\t\t\t\t\targument,\n\t\t\t\t\t\tprefix: true\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tto_check = to_check.substr(0, --tc_len);\n\t\t\t}\n\n\t\t\tif (Jsep.isIdentifierStart(ch)) {\n\t\t\t\tnode = this.gobbleIdentifier();\n\t\t\t\tif (Jsep.literals.hasOwnProperty(node.name)) {\n\t\t\t\t\tnode = {\n\t\t\t\t\t\ttype: Jsep.LITERAL,\n\t\t\t\t\t\tvalue: Jsep.literals[node.name],\n\t\t\t\t\t\traw: node.name,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\telse if (node.name === Jsep.this_str) {\n\t\t\t\t\tnode = { type: Jsep.THIS_EXP };\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ch === Jsep.OPAREN_CODE) { // open parenthesis\n\t\t\t\tnode = this.gobbleGroup();\n\t\t\t}\n\t\t}\n\n\t\tif (!node) {\n\t\t\treturn this.runHook('after-token', false);\n\t\t}\n\n\t\tnode = this.gobbleTokenProperty(node);\n\t\treturn this.runHook('after-token', node);\n\t}\n\n\t/**\n\t * Gobble properties of of identifiers/strings/arrays/groups.\n\t * e.g. `foo`, `bar.baz`, `foo['bar'].baz`\n\t * It also gobbles function calls:\n\t * e.g. `Math.acos(obj.angle)`\n\t * @param {jsep.Expression} node\n\t * @returns {jsep.Expression}\n\t */\n\tgobbleTokenProperty(node) {\n\t\tthis.gobbleSpaces();\n\n\t\tlet ch = this.code;\n\t\twhile (ch === Jsep.PERIOD_CODE || ch === Jsep.OBRACK_CODE || ch === Jsep.OPAREN_CODE || ch === Jsep.QUMARK_CODE) {\n\t\t\tlet optional;\n\t\t\tif (ch === Jsep.QUMARK_CODE) {\n\t\t\t\tif (this.expr.charCodeAt(this.index + 1) !== Jsep.PERIOD_CODE) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\toptional = true;\n\t\t\t\tthis.index += 2;\n\t\t\t\tthis.gobbleSpaces();\n\t\t\t\tch = this.code;\n\t\t\t}\n\t\t\tthis.index++;\n\n\t\t\tif (ch === Jsep.OBRACK_CODE) {\n\t\t\t\tnode = {\n\t\t\t\t\ttype: Jsep.MEMBER_EXP,\n\t\t\t\t\tcomputed: true,\n\t\t\t\t\tobject: node,\n\t\t\t\t\tproperty: this.gobbleExpression()\n\t\t\t\t};\n\t\t\t\tthis.gobbleSpaces();\n\t\t\t\tch = this.code;\n\t\t\t\tif (ch !== Jsep.CBRACK_CODE) {\n\t\t\t\t\tthis.throwError('Unclosed [');\n\t\t\t\t}\n\t\t\t\tthis.index++;\n\t\t\t}\n\t\t\telse if (ch === Jsep.OPAREN_CODE) {\n\t\t\t\t// A function call is being made; gobble all the arguments\n\t\t\t\tnode = {\n\t\t\t\t\ttype: Jsep.CALL_EXP,\n\t\t\t\t\t'arguments': this.gobbleArguments(Jsep.CPAREN_CODE),\n\t\t\t\t\tcallee: node\n\t\t\t\t};\n\t\t\t}\n\t\t\telse if (ch === Jsep.PERIOD_CODE || optional) {\n\t\t\t\tif (optional) {\n\t\t\t\t\tthis.index--;\n\t\t\t\t}\n\t\t\t\tthis.gobbleSpaces();\n\t\t\t\tnode = {\n\t\t\t\t\ttype: Jsep.MEMBER_EXP,\n\t\t\t\t\tcomputed: false,\n\t\t\t\t\tobject: node,\n\t\t\t\t\tproperty: this.gobbleIdentifier(),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (optional) {\n\t\t\t\tnode.optional = true;\n\t\t\t} // else leave undefined for compatibility with esprima\n\n\t\t\tthis.gobbleSpaces();\n\t\t\tch = this.code;\n\t\t}\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to\n\t * keep track of everything in the numeric literal and then calling `parseFloat` on that string\n\t * @returns {jsep.Literal}\n\t */\n\tgobbleNumericLiteral() {\n\t\tlet number = '', ch, chCode;\n\n\t\twhile (Jsep.isDecimalDigit(this.code)) {\n\t\t\tnumber += this.expr.charAt(this.index++);\n\t\t}\n\n\t\tif (this.code === Jsep.PERIOD_CODE) { // can start with a decimal marker\n\t\t\tnumber += this.expr.charAt(this.index++);\n\n\t\t\twhile (Jsep.isDecimalDigit(this.code)) {\n\t\t\t\tnumber += this.expr.charAt(this.index++);\n\t\t\t}\n\t\t}\n\n\t\tch = this.char;\n\n\t\tif (ch === 'e' || ch === 'E') { // exponent marker\n\t\t\tnumber += this.expr.charAt(this.index++);\n\t\t\tch = this.char;\n\n\t\t\tif (ch === '+' || ch === '-') { // exponent sign\n\t\t\t\tnumber += this.expr.charAt(this.index++);\n\t\t\t}\n\n\t\t\twhile (Jsep.isDecimalDigit(this.code)) { // exponent itself\n\t\t\t\tnumber += this.expr.charAt(this.index++);\n\t\t\t}\n\n\t\t\tif (!Jsep.isDecimalDigit(this.expr.charCodeAt(this.index - 1)) ) {\n\t\t\t\tthis.throwError('Expected exponent (' + number + this.char + ')');\n\t\t\t}\n\t\t}\n\n\t\tchCode = this.code;\n\n\t\t// Check to make sure this isn't a variable name that start with a number (123abc)\n\t\tif (Jsep.isIdentifierStart(chCode)) {\n\t\t\tthis.throwError('Variable names cannot start with a number (' +\n\t\t\t\tnumber + this.char + ')');\n\t\t}\n\t\telse if (chCode === Jsep.PERIOD_CODE || (number.length === 1 && number.charCodeAt(0) === Jsep.PERIOD_CODE)) {\n\t\t\tthis.throwError('Unexpected period');\n\t\t}\n\n\t\treturn {\n\t\t\ttype: Jsep.LITERAL,\n\t\t\tvalue: parseFloat(number),\n\t\t\traw: number\n\t\t};\n\t}\n\n\t/**\n\t * Parses a string literal, staring with single or double quotes with basic support for escape codes\n\t * e.g. `\"hello world\"`, `'this is\\nJSEP'`\n\t * @returns {jsep.Literal}\n\t */\n\tgobbleStringLiteral() {\n\t\tlet str = '';\n\t\tconst startIndex = this.index;\n\t\tconst quote = this.expr.charAt(this.index++);\n\t\tlet closed = false;\n\n\t\twhile (this.index < this.expr.length) {\n\t\t\tlet ch = this.expr.charAt(this.index++);\n\n\t\t\tif (ch === quote) {\n\t\t\t\tclosed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (ch === '\\\\') {\n\t\t\t\t// Check for all of the common escape codes\n\t\t\t\tch = this.expr.charAt(this.index++);\n\n\t\t\t\tswitch (ch) {\n\t\t\t\t\tcase 'n': str += '\\n'; break;\n\t\t\t\t\tcase 'r': str += '\\r'; break;\n\t\t\t\t\tcase 't': str += '\\t'; break;\n\t\t\t\t\tcase 'b': str += '\\b'; break;\n\t\t\t\t\tcase 'f': str += '\\f'; break;\n\t\t\t\t\tcase 'v': str += '\\x0B'; break;\n\t\t\t\t\tdefault : str += ch;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstr += ch;\n\t\t\t}\n\t\t}\n\n\t\tif (!closed) {\n\t\t\tthis.throwError('Unclosed quote after \"' + str + '\"');\n\t\t}\n\n\t\treturn {\n\t\t\ttype: Jsep.LITERAL,\n\t\t\tvalue: str,\n\t\t\traw: this.expr.substring(startIndex, this.index),\n\t\t};\n\t}\n\n\t/**\n\t * Gobbles only identifiers\n\t * e.g.: `foo`, `_value`, `$x1`\n\t * Also, this function checks if that identifier is a literal:\n\t * (e.g. `true`, `false`, `null`) or `this`\n\t * @returns {jsep.Identifier}\n\t */\n\tgobbleIdentifier() {\n\t\tlet ch = this.code, start = this.index;\n\n\t\tif (Jsep.isIdentifierStart(ch)) {\n\t\t\tthis.index++;\n\t\t}\n\t\telse {\n\t\t\tthis.throwError('Unexpected ' + this.char);\n\t\t}\n\n\t\twhile (this.index < this.expr.length) {\n\t\t\tch = this.code;\n\n\t\t\tif (Jsep.isIdentifierPart(ch)) {\n\t\t\t\tthis.index++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\ttype: Jsep.IDENTIFIER,\n\t\t\tname: this.expr.slice(start, this.index),\n\t\t};\n\t}\n\n\t/**\n\t * Gobbles a list of arguments within the context of a function call\n\t * or array literal. This function also assumes that the opening character\n\t * `(` or `[` has already been gobbled, and gobbles expressions and commas\n\t * until the terminator character `)` or `]` is encountered.\n\t * e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`\n\t * @param {number} termination\n\t * @returns {jsep.Expression[]}\n\t */\n\tgobbleArguments(termination) {\n\t\tconst args = [];\n\t\tlet closed = false;\n\t\tlet separator_count = 0;\n\n\t\twhile (this.index < this.expr.length) {\n\t\t\tthis.gobbleSpaces();\n\t\t\tlet ch_i = this.code;\n\n\t\t\tif (ch_i === termination) { // done parsing\n\t\t\t\tclosed = true;\n\t\t\t\tthis.index++;\n\n\t\t\t\tif (termination === Jsep.CPAREN_CODE && separator_count && separator_count >= args.length){\n\t\t\t\t\tthis.throwError('Unexpected token ' + String.fromCharCode(termination));\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (ch_i === Jsep.COMMA_CODE) { // between expressions\n\t\t\t\tthis.index++;\n\t\t\t\tseparator_count++;\n\n\t\t\t\tif (separator_count !== args.length) { // missing argument\n\t\t\t\t\tif (termination === Jsep.CPAREN_CODE) {\n\t\t\t\t\t\tthis.throwError('Unexpected token ,');\n\t\t\t\t\t}\n\t\t\t\t\telse if (termination === Jsep.CBRACK_CODE) {\n\t\t\t\t\t\tfor (let arg = args.length; arg < separator_count; arg++) {\n\t\t\t\t\t\t\targs.push(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (args.length !== separator_count && separator_count !== 0) {\n\t\t\t\t// NOTE: `&& separator_count !== 0` allows for either all commas, or all spaces as arguments\n\t\t\t\tthis.throwError('Expected comma');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst node = this.gobbleExpression();\n\n\t\t\t\tif (!node || node.type === Jsep.COMPOUND) {\n\t\t\t\t\tthis.throwError('Expected comma');\n\t\t\t\t}\n\n\t\t\t\targs.push(node);\n\t\t\t}\n\t\t}\n\n\t\tif (!closed) {\n\t\t\tthis.throwError('Expected ' + String.fromCharCode(termination));\n\t\t}\n\n\t\treturn args;\n\t}\n\n\t/**\n\t * Responsible for parsing a group of things within parentheses `()`\n\t * that have no identifier in front (so not a function call)\n\t * This function assumes that it needs to gobble the opening parenthesis\n\t * and then tries to gobble everything within that parenthesis, assuming\n\t * that the next thing it should see is the close parenthesis. If not,\n\t * then the expression probably doesn't have a `)`\n\t * @returns {boolean|jsep.Expression}\n\t */\n\tgobbleGroup() {\n\t\tthis.index++;\n\t\tlet nodes = this.gobbleExpressions(Jsep.CPAREN_CODE);\n\t\tif (this.code === Jsep.CPAREN_CODE) {\n\t\t\tthis.index++;\n\t\t\tif (nodes.length === 1) {\n\t\t\t\treturn nodes[0];\n\t\t\t}\n\t\t\telse if (!nodes.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn {\n\t\t\t\t\ttype: Jsep.SEQUENCE_EXP,\n\t\t\t\t\texpressions: nodes,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis.throwError('Unclosed (');\n\t\t}\n\t}\n\n\t/**\n\t * Responsible for parsing Array literals `[1, 2, 3]`\n\t * This function assumes that it needs to gobble the opening bracket\n\t * and then tries to gobble the expressions as arguments.\n\t * @returns {jsep.ArrayExpression}\n\t */\n\tgobbleArray() {\n\t\tthis.index++;\n\n\t\treturn {\n\t\t\ttype: Jsep.ARRAY_EXP,\n\t\t\telements: this.gobbleArguments(Jsep.CBRACK_CODE)\n\t\t};\n\t}\n}\n\n// Static fields:\nconst hooks = new Hooks();\nObject.assign(Jsep, {\n\thooks,\n\tplugins: new Plugins(Jsep),\n\n\t// Node Types\n\t// ----------\n\t// This is the full set of types that any JSEP node can be.\n\t// Store them here to save space when minified\n\tCOMPOUND:        'Compound',\n\tSEQUENCE_EXP:    'SequenceExpression',\n\tIDENTIFIER:      'Identifier',\n\tMEMBER_EXP:      'MemberExpression',\n\tLITERAL:         'Literal',\n\tTHIS_EXP:        'ThisExpression',\n\tCALL_EXP:        'CallExpression',\n\tUNARY_EXP:       'UnaryExpression',\n\tBINARY_EXP:      'BinaryExpression',\n\tARRAY_EXP:       'ArrayExpression',\n\n\tTAB_CODE:    9,\n\tLF_CODE:     10,\n\tCR_CODE:     13,\n\tSPACE_CODE:  32,\n\tPERIOD_CODE: 46, // '.'\n\tCOMMA_CODE:  44, // ','\n\tSQUOTE_CODE: 39, // single quote\n\tDQUOTE_CODE: 34, // double quotes\n\tOPAREN_CODE: 40, // (\n\tCPAREN_CODE: 41, // )\n\tOBRACK_CODE: 91, // [\n\tCBRACK_CODE: 93, // ]\n\tQUMARK_CODE: 63, // ?\n\tSEMCOL_CODE: 59, // ;\n\tCOLON_CODE:  58, // :\n\n\n\t// Operations\n\t// ----------\n\t// Use a quickly-accessible map to store all of the unary operators\n\t// Values are set to `1` (it really doesn't matter)\n\tunary_ops: {\n\t\t'-': 1,\n\t\t'!': 1,\n\t\t'~': 1,\n\t\t'+': 1\n\t},\n\n\t// Also use a map for the binary operations but set their values to their\n\t// binary precedence for quick reference (higher number = higher precedence)\n\t// see [Order of operations](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)\n\tbinary_ops: {\n\t\t'||': 1, '&&': 2, '|': 3, '^': 4, '&': 5,\n\t\t'==': 6, '!=': 6, '===': 6, '!==': 6,\n\t\t'<': 7, '>': 7, '<=': 7, '>=': 7,\n\t\t'<<': 8, '>>': 8, '>>>': 8,\n\t\t'+': 9, '-': 9,\n\t\t'*': 10, '/': 10, '%': 10\n\t},\n\n\t// sets specific binary_ops as right-associative\n\tright_associative: new Set(),\n\n\t// Additional valid identifier chars, apart from a-z, A-Z and 0-9 (except on the starting char)\n\tadditional_identifier_chars: new Set(['$', '_']),\n\n\t// Literals\n\t// ----------\n\t// Store the values to return for the various literals we may encounter\n\tliterals: {\n\t\t'true': true,\n\t\t'false': false,\n\t\t'null': null\n\t},\n\n\t// Except for `this`, which is special. This could be changed to something like `'self'` as well\n\tthis_str: 'this',\n});\nJsep.max_unop_len = Jsep.getMaxKeyLen(Jsep.unary_ops);\nJsep.max_binop_len = Jsep.getMaxKeyLen(Jsep.binary_ops);\n\n// Backward Compatibility:\nconst jsep = expr => (new Jsep(expr)).parse();\nconst staticMethods = Object.getOwnPropertyNames(Jsep);\nstaticMethods\n\t.forEach((m) => {\n\t\tif (jsep[m] === undefined && m !== 'prototype') {\n\t\t\tjsep[m] = Jsep[m];\n\t\t}\n\t});\njsep.Jsep = Jsep; // allows for const { Jsep } = require('jsep');\n\nconst CONDITIONAL_EXP = 'ConditionalExpression';\n\nvar ternary = {\n\tname: 'ternary',\n\n\tinit(jsep) {\n\t\t// Ternary expression: test ? consequent : alternate\n\t\tjsep.hooks.add('after-expression', function gobbleTernary(env) {\n\t\t\tif (env.node && this.code === jsep.QUMARK_CODE) {\n\t\t\t\tthis.index++;\n\t\t\t\tconst test = env.node;\n\t\t\t\tconst consequent = this.gobbleExpression();\n\n\t\t\t\tif (!consequent) {\n\t\t\t\t\tthis.throwError('Expected expression');\n\t\t\t\t}\n\n\t\t\t\tthis.gobbleSpaces();\n\n\t\t\t\tif (this.code === jsep.COLON_CODE) {\n\t\t\t\t\tthis.index++;\n\t\t\t\t\tconst alternate = this.gobbleExpression();\n\n\t\t\t\t\tif (!alternate) {\n\t\t\t\t\t\tthis.throwError('Expected expression');\n\t\t\t\t\t}\n\t\t\t\t\tenv.node = {\n\t\t\t\t\t\ttype: CONDITIONAL_EXP,\n\t\t\t\t\t\ttest,\n\t\t\t\t\t\tconsequent,\n\t\t\t\t\t\talternate,\n\t\t\t\t\t};\n\n\t\t\t\t\t// check for operators of higher priority than ternary (i.e. assignment)\n\t\t\t\t\t// jsep sets || at 1, and assignment at 0.9, and conditional should be between them\n\t\t\t\t\tif (test.operator && jsep.binary_ops[test.operator] <= 0.9) {\n\t\t\t\t\t\tlet newTest = test;\n\t\t\t\t\t\twhile (newTest.right.operator && jsep.binary_ops[newTest.right.operator] <= 0.9) {\n\t\t\t\t\t\t\tnewTest = newTest.right;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tenv.node.test = newTest.right;\n\t\t\t\t\t\tnewTest.right = env.node;\n\t\t\t\t\t\tenv.node = test;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.throwError('Expected :');\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t},\n};\n\n// Add default plugins:\n\njsep.plugins.register(ternary);\n\nexport { Jsep, jsep as default };\n","const FSLASH_CODE = 47; // '/'\nconst BSLASH_CODE = 92; // '\\\\'\n\nvar index = {\n\tname: 'regex',\n\n\tinit(jsep) {\n\t\t// Regex literal: /abc123/ig\n\t\tjsep.hooks.add('gobble-token', function gobbleRegexLiteral(env) {\n\t\t\tif (this.code === FSLASH_CODE) {\n\t\t\t\tconst patternIndex = ++this.index;\n\n\t\t\t\tlet inCharSet = false;\n\t\t\t\twhile (this.index < this.expr.length) {\n\t\t\t\t\tif (this.code === FSLASH_CODE && !inCharSet) {\n\t\t\t\t\t\tconst pattern = this.expr.slice(patternIndex, this.index);\n\n\t\t\t\t\t\tlet flags = '';\n\t\t\t\t\t\twhile (++this.index < this.expr.length) {\n\t\t\t\t\t\t\tconst code = this.code;\n\t\t\t\t\t\t\tif ((code >= 97 && code <= 122) // a...z\n\t\t\t\t\t\t\t\t|| (code >= 65 && code <= 90) // A...Z\n\t\t\t\t\t\t\t\t|| (code >= 48 && code <= 57)) { // 0-9\n\t\t\t\t\t\t\t\tflags += this.char;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet value;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tvalue = new RegExp(pattern, flags);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\t\tthis.throwError(e.message);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tenv.node = {\n\t\t\t\t\t\t\ttype: jsep.LITERAL,\n\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\traw: this.expr.slice(patternIndex - 1, this.index),\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// allow . [] and () after regex: /regex/.test(a)\n\t\t\t\t\t\tenv.node = this.gobbleTokenProperty(env.node);\n\t\t\t\t\t\treturn env.node;\n\t\t\t\t\t}\n\t\t\t\t\tif (this.code === jsep.OBRACK_CODE) {\n\t\t\t\t\t\tinCharSet = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (inCharSet && this.code === jsep.CBRACK_CODE) {\n\t\t\t\t\t\tinCharSet = false;\n\t\t\t\t\t}\n\t\t\t\t\tthis.index += this.code === BSLASH_CODE ? 2 : 1;\n\t\t\t\t}\n\t\t\t\tthis.throwError('Unclosed Regex');\n\t\t\t}\n\t\t});\n\t},\n};\n\nexport { index as default };\n","const {hasOwnProperty: hasOwnProp} = Object.prototype;\n\n/**\n * @typedef {null|boolean|number|string|PlainObject|GenericArray} JSONObject\n */\n\n/**\n * @typedef {any} AnyItem\n */\n\n/**\n * @typedef {any} AnyResult\n */\n\n/**\n * Copies array and then pushes item into it.\n * @param {GenericArray} arr Array to copy and into which to push\n * @param {AnyItem} item Array item to add (to end)\n * @returns {GenericArray} Copy of the original array\n */\nfunction push (arr, item) {\n    arr = arr.slice();\n    arr.push(item);\n    return arr;\n}\n/**\n * Copies array and then unshifts item into it.\n * @param {AnyItem} item Array item to add (to beginning)\n * @param {GenericArray} arr Array to copy and into which to unshift\n * @returns {GenericArray} Copy of the original array\n */\nfunction unshift (item, arr) {\n    arr = arr.slice();\n    arr.unshift(item);\n    return arr;\n}\n\n/**\n * Caught when JSONPath is used without `new` but rethrown if with `new`\n * @extends Error\n */\nclass NewError extends Error {\n    /**\n     * @param {AnyResult} value The evaluated scalar value\n     */\n    constructor (value) {\n        super(\n            'JSONPath should not be called with \"new\" (it prevents return ' +\n            'of (unwrapped) scalar values)'\n        );\n        this.avoidNew = true;\n        this.value = value;\n        this.name = 'NewError';\n    }\n}\n\n/**\n* @typedef {PlainObject} ReturnObject\n* @property {string} path\n* @property {JSONObject} value\n* @property {PlainObject|GenericArray} parent\n* @property {string} parentProperty\n*/\n\n/**\n* @callback JSONPathCallback\n* @param {string|PlainObject} preferredOutput\n* @param {\"value\"|\"property\"} type\n* @param {ReturnObject} fullRetObj\n* @returns {void}\n*/\n\n/**\n* @callback OtherTypeCallback\n* @param {JSONObject} val\n* @param {string} path\n* @param {PlainObject|GenericArray} parent\n* @param {string} parentPropName\n* @returns {boolean}\n*/\n\n/* eslint-disable max-len -- Can make multiline type after https://github.com/syavorsky/comment-parser/issues/109 */\n/**\n * @typedef {PlainObject} JSONPathOptions\n * @property {JSON} json\n * @property {string|string[]} path\n * @property {\"value\"|\"path\"|\"pointer\"|\"parent\"|\"parentProperty\"|\"all\"} [resultType=\"value\"]\n * @property {boolean} [flatten=false]\n * @property {boolean} [wrap=true]\n * @property {PlainObject} [sandbox={}]\n * @property {boolean} [preventEval=false]\n * @property {\"safe\"|\"native\"|\"none\"} [evalType='safe']\n * @property {PlainObject|GenericArray|null} [parent=null]\n * @property {string|null} [parentProperty=null]\n * @property {JSONPathCallback} [callback]\n * @property {OtherTypeCallback} [otherTypeCallback] Defaults to\n *   function which throws on encountering `@other`\n * @property {boolean} [autostart=true]\n */\n/* eslint-enable max-len -- Can make multiline type after https://github.com/syavorsky/comment-parser/issues/109 */\n\n/**\n * @param {string|JSONPathOptions} opts If a string, will be treated as `expr`\n * @param {string} [expr] JSON path to evaluate\n * @param {JSON} [obj] JSON object to evaluate against\n * @param {JSONPathCallback} [callback] Passed 3 arguments: 1) desired payload\n *     per `resultType`, 2) `\"value\"|\"property\"`, 3) Full returned object with\n *     all payloads\n * @param {OtherTypeCallback} [otherTypeCallback] If `@other()` is at the end\n *   of one's query, this will be invoked with the value of the item, its\n *   path, its parent, and its parent's property name, and it should return\n *   a boolean indicating whether the supplied value belongs to the \"other\"\n *   type or not (or it may handle transformations and return `false`).\n * @returns {JSONPath}\n * @class\n */\nfunction JSONPath (opts, expr, obj, callback, otherTypeCallback) {\n    // eslint-disable-next-line no-restricted-syntax\n    if (!(this instanceof JSONPath)) {\n        try {\n            return new JSONPath(opts, expr, obj, callback, otherTypeCallback);\n        } catch (e) {\n            if (!e.avoidNew) {\n                throw e;\n            }\n            return e.value;\n        }\n    }\n\n    if (typeof opts === 'string') {\n        otherTypeCallback = callback;\n        callback = obj;\n        obj = expr;\n        expr = opts;\n        opts = null;\n    }\n    const optObj = opts && typeof opts === 'object';\n    opts = opts || {};\n    this.json = opts.json || obj;\n    this.path = opts.path || expr;\n    this.resultType = opts.resultType || 'value';\n    this.flatten = opts.flatten || false;\n    this.wrap = hasOwnProp.call(opts, 'wrap') ? opts.wrap : true;\n    this.sandbox = opts.sandbox || {};\n    this.preventEval = opts.preventEval || false;\n    this.evalType = opts.evalType || 'safe';\n    this.parent = opts.parent || null;\n    this.parentProperty = opts.parentProperty || null;\n    this.callback = opts.callback || callback || null;\n    this.otherTypeCallback = opts.otherTypeCallback ||\n        otherTypeCallback ||\n        function () {\n            throw new TypeError(\n                'You must supply an otherTypeCallback callback option ' +\n                'with the @other() operator.'\n            );\n        };\n\n    if (opts.autostart !== false) {\n        const args = {\n            path: (optObj ? opts.path : expr)\n        };\n        if (!optObj) {\n            args.json = obj;\n        } else if ('json' in opts) {\n            args.json = opts.json;\n        }\n        const ret = this.evaluate(args);\n        if (!ret || typeof ret !== 'object') {\n            throw new NewError(ret);\n        }\n        return ret;\n    }\n}\n\n// PUBLIC METHODS\nJSONPath.prototype.evaluate = function (\n    expr, json, callback, otherTypeCallback\n) {\n    let currParent = this.parent,\n        currParentProperty = this.parentProperty;\n    let {flatten, wrap} = this;\n\n    this.currResultType = this.resultType;\n    this.currPreventEval = this.preventEval;\n    this.currEvalType = this.evalType;\n    this.currSandbox = this.sandbox;\n    callback = callback || this.callback;\n    this.currOtherTypeCallback = otherTypeCallback || this.otherTypeCallback;\n\n    json = json || this.json;\n    expr = expr || this.path;\n    if (expr && typeof expr === 'object' && !Array.isArray(expr)) {\n        if (!expr.path && expr.path !== '') {\n            throw new TypeError(\n                'You must supply a \"path\" property when providing an object ' +\n                'argument to JSONPath.evaluate().'\n            );\n        }\n        if (!(hasOwnProp.call(expr, 'json'))) {\n            throw new TypeError(\n                'You must supply a \"json\" property when providing an object ' +\n                'argument to JSONPath.evaluate().'\n            );\n        }\n        ({json} = expr);\n        flatten = hasOwnProp.call(expr, 'flatten') ? expr.flatten : flatten;\n        this.currResultType = hasOwnProp.call(expr, 'resultType')\n            ? expr.resultType\n            : this.currResultType;\n        this.currSandbox = hasOwnProp.call(expr, 'sandbox')\n            ? expr.sandbox\n            : this.currSandbox;\n        wrap = hasOwnProp.call(expr, 'wrap') ? expr.wrap : wrap;\n        this.currPreventEval = hasOwnProp.call(expr, 'preventEval')\n            ? expr.preventEval\n            : this.currPreventEval;\n        this.currEvalType = hasOwnProp.call(expr, 'evalType')\n            ? expr.evalType\n            : this.currEvalType;\n        callback = hasOwnProp.call(expr, 'callback') ? expr.callback : callback;\n        this.currOtherTypeCallback = hasOwnProp.call(expr, 'otherTypeCallback')\n            ? expr.otherTypeCallback\n            : this.currOtherTypeCallback;\n        currParent = hasOwnProp.call(expr, 'parent') ? expr.parent : currParent;\n        currParentProperty = hasOwnProp.call(expr, 'parentProperty')\n            ? expr.parentProperty\n            : currParentProperty;\n        expr = expr.path;\n    }\n    currParent = currParent || null;\n    currParentProperty = currParentProperty || null;\n\n    if (Array.isArray(expr)) {\n        expr = JSONPath.toPathString(expr);\n    }\n    if ((!expr && expr !== '') || !json) {\n        return undefined;\n    }\n\n    const exprList = JSONPath.toPathArray(expr);\n    if (exprList[0] === '$' && exprList.length > 1) { exprList.shift(); }\n    this._hasParentSelector = null;\n    const result = this\n        ._trace(\n            exprList, json, ['$'], currParent, currParentProperty, callback\n        )\n        .filter(function (ea) { return ea && !ea.isParentSelector; });\n\n    if (!result.length) { return wrap ? [] : undefined; }\n    if (!wrap && result.length === 1 && !result[0].hasArrExpr) {\n        return this._getPreferredOutput(result[0]);\n    }\n    return result.reduce((rslt, ea) => {\n        const valOrPath = this._getPreferredOutput(ea);\n        if (flatten && Array.isArray(valOrPath)) {\n            rslt = rslt.concat(valOrPath);\n        } else {\n            rslt.push(valOrPath);\n        }\n        return rslt;\n    }, []);\n};\n\n// PRIVATE METHODS\n\nJSONPath.prototype._getPreferredOutput = function (ea) {\n    const resultType = this.currResultType;\n    switch (resultType) {\n    case 'all': {\n        const path = Array.isArray(ea.path)\n            ? ea.path\n            : JSONPath.toPathArray(ea.path);\n        ea.pointer = JSONPath.toPointer(path);\n        ea.path = typeof ea.path === 'string'\n            ? ea.path\n            : JSONPath.toPathString(ea.path);\n        return ea;\n    } case 'value': case 'parent': case 'parentProperty':\n        return ea[resultType];\n    case 'path':\n        return JSONPath.toPathString(ea[resultType]);\n    case 'pointer':\n        return JSONPath.toPointer(ea.path);\n    default:\n        throw new TypeError('Unknown result type');\n    }\n};\n\nJSONPath.prototype._handleCallback = function (fullRetObj, callback, type) {\n    if (callback) {\n        const preferredOutput = this._getPreferredOutput(fullRetObj);\n        fullRetObj.path = typeof fullRetObj.path === 'string'\n            ? fullRetObj.path\n            : JSONPath.toPathString(fullRetObj.path);\n        // eslint-disable-next-line n/callback-return\n        callback(preferredOutput, type, fullRetObj);\n    }\n};\n\n/**\n *\n * @param {string} expr\n * @param {JSONObject} val\n * @param {string} path\n * @param {PlainObject|GenericArray} parent\n * @param {string} parentPropName\n * @param {JSONPathCallback} callback\n * @param {boolean} hasArrExpr\n * @param {boolean} literalPriority\n * @returns {ReturnObject|ReturnObject[]}\n */\nJSONPath.prototype._trace = function (\n    expr, val, path, parent, parentPropName, callback, hasArrExpr,\n    literalPriority\n) {\n    // No expr to follow? return path and value as the result of\n    //  this trace branch\n    let retObj;\n    if (!expr.length) {\n        retObj = {\n            path,\n            value: val,\n            parent,\n            parentProperty: parentPropName,\n            hasArrExpr\n        };\n        this._handleCallback(retObj, callback, 'value');\n        return retObj;\n    }\n\n    const loc = expr[0], x = expr.slice(1);\n\n    // We need to gather the return value of recursive trace calls in order to\n    // do the parent sel computation.\n    const ret = [];\n    /**\n     *\n     * @param {ReturnObject|ReturnObject[]} elems\n     * @returns {void}\n     */\n    function addRet (elems) {\n        if (Array.isArray(elems)) {\n            // This was causing excessive stack size in Node (with or\n            //  without Babel) against our performance test:\n            //  `ret.push(...elems);`\n            elems.forEach((t) => {\n                ret.push(t);\n            });\n        } else {\n            ret.push(elems);\n        }\n    }\n    if ((typeof loc !== 'string' || literalPriority) && val &&\n        hasOwnProp.call(val, loc)\n    ) { // simple case--directly follow property\n        addRet(this._trace(x, val[loc], push(path, loc), val, loc, callback,\n            hasArrExpr));\n    // eslint-disable-next-line unicorn/prefer-switch -- Part of larger `if`\n    } else if (loc === '*') { // all child properties\n        this._walk(val, (m) => {\n            addRet(this._trace(\n                x, val[m], push(path, m), val, m, callback, true, true\n            ));\n        });\n    } else if (loc === '..') { // all descendent parent properties\n        // Check remaining expression with val's immediate children\n        addRet(\n            this._trace(x, val, path, parent, parentPropName, callback,\n                hasArrExpr)\n        );\n        this._walk(val, (m) => {\n            // We don't join m and x here because we only want parents,\n            //   not scalar values\n            if (typeof val[m] === 'object') {\n                // Keep going with recursive descent on val's\n                //   object children\n                addRet(this._trace(\n                    expr.slice(), val[m], push(path, m), val, m, callback, true\n                ));\n            }\n        });\n    // The parent sel computation is handled in the frame above using the\n    // ancestor object of val\n    } else if (loc === '^') {\n        // This is not a final endpoint, so we do not invoke the callback here\n        this._hasParentSelector = true;\n        return {\n            path: path.slice(0, -1),\n            expr: x,\n            isParentSelector: true\n        };\n    } else if (loc === '~') { // property name\n        retObj = {\n            path: push(path, loc),\n            value: parentPropName,\n            parent,\n            parentProperty: null\n        };\n        this._handleCallback(retObj, callback, 'property');\n        return retObj;\n    } else if (loc === '$') { // root only\n        addRet(this._trace(x, val, path, null, null, callback, hasArrExpr));\n    } else if ((/^(-?\\d*):(-?\\d*):?(\\d*)$/u).test(loc)) { // [start:end:step]  Python slice syntax\n        addRet(\n            this._slice(loc, x, val, path, parent, parentPropName, callback)\n        );\n    } else if (loc.indexOf('?(') === 0) { // [?(expr)] (filtering)\n        if (this.currPreventEval || this.currEvalType === 'none') {\n            throw new Error('Eval [?(expr)] prevented in JSONPath expression.');\n        }\n        const safeLoc = loc.replace(/^\\?\\((.*?)\\)$/u, '$1');\n        this._walk(val, (m) => {\n            if (this._eval(safeLoc, val[m], m, path, parent, parentPropName)) {\n                addRet(this._trace(x, val[m], push(path, m), val, m, callback,\n                    true));\n            }\n        });\n    } else if (loc[0] === '(') { // [(expr)] (dynamic property/index)\n        if (this.currPreventEval || this.currEvalType === 'none') {\n            throw new Error('Eval [(expr)] prevented in JSONPath expression.');\n        }\n        // As this will resolve to a property name (but we don't know it\n        //  yet), property and parent information is relative to the\n        //  parent of the property to which this expression will resolve\n        addRet(this._trace(unshift(\n            this._eval(\n                loc, val, path[path.length - 1],\n                path.slice(0, -1), parent, parentPropName\n            ),\n            x\n        ), val, path, parent, parentPropName, callback, hasArrExpr));\n    } else if (loc[0] === '@') { // value type: @boolean(), etc.\n        let addType = false;\n        const valueType = loc.slice(1, -2);\n        switch (valueType) {\n        case 'scalar':\n            if (!val || !(['object', 'function'].includes(typeof val))) {\n                addType = true;\n            }\n            break;\n        case 'boolean': case 'string': case 'undefined': case 'function':\n            // eslint-disable-next-line valid-typeof\n            if (typeof val === valueType) {\n                addType = true;\n            }\n            break;\n        case 'integer':\n            if (Number.isFinite(val) && !(val % 1)) {\n                addType = true;\n            }\n            break;\n        case 'number':\n            if (Number.isFinite(val)) {\n                addType = true;\n            }\n            break;\n        case 'nonFinite':\n            if (typeof val === 'number' && !Number.isFinite(val)) {\n                addType = true;\n            }\n            break;\n        case 'object':\n            // eslint-disable-next-line valid-typeof\n            if (val && typeof val === valueType) {\n                addType = true;\n            }\n            break;\n        case 'array':\n            if (Array.isArray(val)) {\n                addType = true;\n            }\n            break;\n        case 'other':\n            addType = this.currOtherTypeCallback(\n                val, path, parent, parentPropName\n            );\n            break;\n        case 'null':\n            if (val === null) {\n                addType = true;\n            }\n            break;\n        /* c8 ignore next 2 */\n        default:\n            throw new TypeError('Unknown value type ' + valueType);\n        }\n        if (addType) {\n            retObj = {path, value: val, parent, parentProperty: parentPropName};\n            this._handleCallback(retObj, callback, 'value');\n            return retObj;\n        }\n    // `-escaped property\n    } else if (loc[0] === '`' && val && hasOwnProp.call(val, loc.slice(1))) {\n        const locProp = loc.slice(1);\n        addRet(this._trace(\n            x, val[locProp], push(path, locProp), val, locProp, callback,\n            hasArrExpr, true\n        ));\n    } else if (loc.includes(',')) { // [name1,name2,...]\n        const parts = loc.split(',');\n        for (const part of parts) {\n            addRet(this._trace(\n                unshift(part, x), val, path, parent, parentPropName, callback,\n                true\n            ));\n        }\n    // simple case--directly follow property\n    } else if (\n        !literalPriority && val && hasOwnProp.call(val, loc)\n    ) {\n        addRet(\n            this._trace(x, val[loc], push(path, loc), val, loc, callback,\n                hasArrExpr, true)\n        );\n    }\n\n    // We check the resulting values for parent selections. For parent\n    // selections we discard the value object and continue the trace with the\n    // current val object\n    if (this._hasParentSelector) {\n        for (let t = 0; t < ret.length; t++) {\n            const rett = ret[t];\n            if (rett && rett.isParentSelector) {\n                const tmp = this._trace(\n                    rett.expr, val, rett.path, parent, parentPropName, callback,\n                    hasArrExpr\n                );\n                if (Array.isArray(tmp)) {\n                    ret[t] = tmp[0];\n                    const tl = tmp.length;\n                    for (let tt = 1; tt < tl; tt++) {\n                        t++;\n                        ret.splice(t, 0, tmp[tt]);\n                    }\n                } else {\n                    ret[t] = tmp;\n                }\n            }\n        }\n    }\n    return ret;\n};\n\nJSONPath.prototype._walk = function (val, f) {\n    if (Array.isArray(val)) {\n        const n = val.length;\n        for (let i = 0; i < n; i++) {\n            f(i);\n        }\n    } else if (val && typeof val === 'object') {\n        Object.keys(val).forEach((m) => {\n            f(m);\n        });\n    }\n};\n\nJSONPath.prototype._slice = function (\n    loc, expr, val, path, parent, parentPropName, callback\n) {\n    if (!Array.isArray(val)) { return undefined; }\n    const len = val.length, parts = loc.split(':'),\n        step = (parts[2] && Number.parseInt(parts[2])) || 1;\n    let start = (parts[0] && Number.parseInt(parts[0])) || 0,\n        end = (parts[1] && Number.parseInt(parts[1])) || len;\n    start = (start < 0) ? Math.max(0, start + len) : Math.min(len, start);\n    end = (end < 0) ? Math.max(0, end + len) : Math.min(len, end);\n    const ret = [];\n    for (let i = start; i < end; i += step) {\n        const tmp = this._trace(\n            unshift(i, expr), val, path, parent, parentPropName, callback, true\n        );\n        // Should only be possible to be an array here since first part of\n        //   ``unshift(i, expr)` passed in above would not be empty, nor `~`,\n        //     nor begin with `@` (as could return objects)\n        // This was causing excessive stack size in Node (with or\n        //  without Babel) against our performance test: `ret.push(...tmp);`\n        tmp.forEach((t) => {\n            ret.push(t);\n        });\n    }\n    return ret;\n};\n\nJSONPath.prototype._eval = function (\n    code, _v, _vname, path, parent, parentPropName\n) {\n    this.currSandbox._$_parentProperty = parentPropName;\n    this.currSandbox._$_parent = parent;\n    this.currSandbox._$_property = _vname;\n    this.currSandbox._$_root = this.json;\n    this.currSandbox._$_v = _v;\n\n    const containsPath = code.includes('@path');\n    if (containsPath) {\n        this.currSandbox._$_path = JSONPath.toPathString(path.concat([_vname]));\n    }\n\n    const scriptCacheKey = this.currEvalType + 'Script:' + code;\n    if (!JSONPath.cache[scriptCacheKey]) {\n        let script = code\n            .replace(/@parentProperty/gu, '_$_parentProperty')\n            .replace(/@parent/gu, '_$_parent')\n            .replace(/@property/gu, '_$_property')\n            .replace(/@root/gu, '_$_root')\n            .replace(/@([.\\s)[])/gu, '_$_v$1');\n        if (containsPath) {\n            script = script.replace(/@path/gu, '_$_path');\n        }\n        if (this.currEvalType === 'safe') {\n            JSONPath.cache[scriptCacheKey] = new this.safeVm.Script(script);\n        } else if (this.currEvalType === 'native') {\n            JSONPath.cache[scriptCacheKey] = new this.vm.Script(script);\n        }\n    }\n\n    try {\n        return JSONPath.cache[scriptCacheKey].runInNewContext(this.currSandbox);\n    } catch (e) {\n        throw new Error('jsonPath: ' + e.message + ': ' + code);\n    }\n};\n\n// PUBLIC CLASS PROPERTIES AND METHODS\n\n// Could store the cache object itself\nJSONPath.cache = {};\n\n/**\n * @param {string[]} pathArr Array to convert\n * @returns {string} The path string\n */\nJSONPath.toPathString = function (pathArr) {\n    const x = pathArr, n = x.length;\n    let p = '$';\n    for (let i = 1; i < n; i++) {\n        if (!(/^(~|\\^|@.*?\\(\\))$/u).test(x[i])) {\n            p += (/^[0-9*]+$/u).test(x[i]) ? ('[' + x[i] + ']') : (\"['\" + x[i] + \"']\");\n        }\n    }\n    return p;\n};\n\n/**\n * @param {string} pointer JSON Path\n * @returns {string} JSON Pointer\n */\nJSONPath.toPointer = function (pointer) {\n    const x = pointer, n = x.length;\n    let p = '';\n    for (let i = 1; i < n; i++) {\n        if (!(/^(~|\\^|@.*?\\(\\))$/u).test(x[i])) {\n            p += '/' + x[i].toString()\n                .replace(/~/gu, '~0')\n                .replace(/\\//gu, '~1');\n        }\n    }\n    return p;\n};\n\n/**\n * @param {string} expr Expression to convert\n * @returns {string[]}\n */\nJSONPath.toPathArray = function (expr) {\n    const {cache} = JSONPath;\n    if (cache[expr]) { return cache[expr].concat(); }\n    const subx = [];\n    const normalized = expr\n        // Properties\n        .replace(\n            /@(?:null|boolean|number|string|integer|undefined|nonFinite|scalar|array|object|function|other)\\(\\)/gu,\n            ';$&;'\n        )\n        // Parenthetical evaluations (filtering and otherwise), directly\n        //   within brackets or single quotes\n        .replace(/[['](\\??\\(.*?\\))[\\]']/gu, function ($0, $1) {\n            return '[#' + (subx.push($1) - 1) + ']';\n        })\n        // Escape periods and tildes within properties\n        .replace(/\\[['\"]([^'\\]]*)['\"]\\]/gu, function ($0, prop) {\n            return \"['\" + prop\n                .replace(/\\./gu, '%@%')\n                .replace(/~/gu, '%%@@%%') +\n                \"']\";\n        })\n        // Properties operator\n        .replace(/~/gu, ';~;')\n        // Split by property boundaries\n        .replace(/['\"]?\\.['\"]?(?![^[]*\\])|\\[['\"]?/gu, ';')\n        // Reinsert periods within properties\n        .replace(/%@%/gu, '.')\n        // Reinsert tildes within properties\n        .replace(/%%@@%%/gu, '~')\n        // Parent\n        .replace(/(?:;)?(\\^+)(?:;)?/gu, function ($0, ups) {\n            return ';' + ups.split('').join(';') + ';';\n        })\n        // Descendents\n        .replace(/;;;|;;/gu, ';..;')\n        // Remove trailing\n        .replace(/;$|'?\\]|'$/gu, '');\n\n    const exprList = normalized.split(';').map(function (exp) {\n        const match = exp.match(/#(\\d+)/u);\n        return !match || !match[1] ? exp : subx[match[1]];\n    });\n    cache[expr] = exprList;\n    return cache[expr].concat();\n};\n\nexport {JSONPath};\n","/* eslint-disable no-bitwise */\nimport jsep from 'jsep';\nimport jsepRegex from '@jsep-plugin/regex';\nimport {JSONPath} from './jsonpath.js';\n\n/**\n * @typedef {any} ContextItem\n */\n\n/**\n * @typedef {any} EvaluatedResult\n */\n\n/**\n * @callback ConditionCallback\n * @param {ContextItem} item\n * @returns {boolean}\n */\n\n/**\n * Copy items out of one array into another.\n * @param {GenericArray} source Array with items to copy\n * @param {GenericArray} target Array to which to copy\n * @param {ConditionCallback} conditionCb Callback passed the current item;\n *     will move item if evaluates to `true`\n * @returns {void}\n */\nconst moveToAnotherArray = function (source, target, conditionCb) {\n    const il = source.length;\n    for (let i = 0; i < il; i++) {\n        const item = source[i];\n        if (conditionCb(item)) {\n            target.push(source.splice(i--, 1)[0]);\n        }\n    }\n};\n\n// register plugins\njsep.plugins.register(jsepRegex);\n\nconst SafeEval = {\n    eval (code, substitions = {}) {\n        const ast = jsep(code);\n        return SafeEval.evalAst(ast, substitions);\n    },\n    /**\n     * @param {jsep.Expression} ast\n     * @param {Record<string, any>} subs\n     */\n    evalAst (ast, subs) {\n        switch (ast.type) {\n        case 'BinaryExpression':\n        case 'LogicalExpression':\n            return SafeEval.evalBinaryExpression(ast, subs);\n        case 'Compound':\n            return SafeEval.evalCompound(ast, subs);\n        case 'ConditionalExpression':\n            return SafeEval.evalConditionalExpression(ast, subs);\n        case 'Identifier':\n            return SafeEval.evalIdentifier(ast, subs);\n        case 'Literal':\n            return SafeEval.evalLiteral(ast, subs);\n        case 'MemberExpression':\n            return SafeEval.evalMemberExpression(ast, subs);\n        case 'UnaryExpression':\n            return SafeEval.evalUnaryExpression(ast, subs);\n        case 'ArrayExpression':\n            return SafeEval.evalArrayExpression(ast, subs);\n        case 'CallExpression':\n            return SafeEval.evalCallExpression(ast, subs);\n        default:\n            throw SyntaxError('Unexpected expression', ast);\n        }\n    },\n    evalBinaryExpression (ast, subs) {\n        const result = ({\n            '||': (a, b) => a || b(),\n            '&&': (a, b) => a && b(),\n            '|': (a, b) => a | b(),\n            '^': (a, b) => a ^ b(),\n            '&': (a, b) => a & b(),\n            // eslint-disable-next-line eqeqeq\n            '==': (a, b) => a == b(),\n            // eslint-disable-next-line eqeqeq\n            '!=': (a, b) => a != b(),\n            '===': (a, b) => a === b(),\n            '!==': (a, b) => a !== b(),\n            '<': (a, b) => a < b(),\n            '>': (a, b) => a > b(),\n            '<=': (a, b) => a <= b(),\n            '>=': (a, b) => a >= b(),\n            '<<': (a, b) => a << b(),\n            '>>': (a, b) => a >> b(),\n            '>>>': (a, b) => a >>> b(),\n            '+': (a, b) => a + b(),\n            '-': (a, b) => a - b(),\n            '*': (a, b) => a * b(),\n            '/': (a, b) => a / b(),\n            '%': (a, b) => a % b()\n        })[ast.operator](SafeEval.evalAst(ast.left, subs), () => SafeEval.evalAst(ast.right, subs));\n        return result;\n    },\n    evalCompound (ast, subs) {\n        let last;\n        for (const expr of ast.body) {\n            last = this.evalAst(expr, subs);\n        }\n        return last;\n    },\n    evalConditionalExpression (ast, subs) {\n        if (SafeEval.evalAst(ast.test, subs)) {\n            return SafeEval.evalAst(ast.consequent, subs);\n        }\n        return SafeEval.evalAst(ast.alternate, subs);\n    },\n    evalIdentifier (ast, subs) {\n        if (ast.name in subs) {\n            return subs[ast.name];\n        }\n        throw ReferenceError(`${ast.name} is not defined`);\n    },\n    evalLiteral (ast, subs) {\n        return ast.value;\n    },\n    evalMemberExpression (ast, subs) {\n        const prop = ast.computed\n            ? SafeEval.evalAst(ast.property) // `object[property]`\n            : ast.property.name; // `object.property` property is identifier\n        const obj = SafeEval.evalAst(ast.object, subs);\n        const result = obj[prop];\n        if (typeof result === 'function') {\n            return result.bind(obj); // arrow functions aren't affected by bind.\n        }\n        return result;\n    },\n    evalUnaryExpression (ast, subs) {\n        const result = ({\n            '-': (a) => -SafeEval.evalAst(a),\n            '!': (a) => !SafeEval.evalAst(a),\n            '~': (a) => ~SafeEval.evalAst(a),\n            // eslint-disable-next-line no-implicit-coercion\n            '+': (a) => +SafeEval.evalAst(a)\n        })[ast.operator](ast.argument);\n        return result;\n    },\n    evalArrayExpression (ast, subs) {\n        return ast.elements.map((el) => SafeEval.evalAst(el, subs));\n    },\n    evalCallExpression (ast, subs) {\n        const args = ast.arguments.map((arg) => SafeEval.evalAst(arg, subs));\n        const func = SafeEval.evalAst(ast.callee, subs);\n        return func(...args);\n    }\n};\n\n/**\n * In-browser replacement for NodeJS' VM.Script.\n */\nclass SafeScript {\n    /**\n     * @param {string} expr Expression to evaluate\n     */\n    constructor (expr) {\n        this.code = expr;\n    }\n\n    /**\n     * @param {PlainObject} context Object whose items will be added\n     *   to evaluation\n     * @returns {EvaluatedResult} Result of evaluated code\n     */\n    runInNewContext (context) {\n        const keyMap = {...context};\n        return SafeEval.eval(this.code, keyMap);\n    }\n}\n\n/**\n * In-browser replacement for NodeJS' VM.Script.\n */\nclass Script {\n    /**\n     * @param {string} expr Expression to evaluate\n     */\n    constructor (expr) {\n        this.code = expr;\n    }\n\n    /**\n     * @param {PlainObject} context Object whose items will be added\n     *   to evaluation\n     * @returns {EvaluatedResult} Result of evaluated code\n     */\n    runInNewContext (context) {\n        let expr = this.code;\n        const keys = Object.keys(context);\n        const funcs = [];\n        moveToAnotherArray(keys, funcs, (key) => {\n            return typeof context[key] === 'function';\n        });\n        const values = keys.map((vr, i) => {\n            return context[vr];\n        });\n\n        const funcString = funcs.reduce((s, func) => {\n            let fString = context[func].toString();\n            if (!(/function/u).test(fString)) {\n                fString = 'function ' + fString;\n            }\n            return 'var ' + func + '=' + fString + ';' + s;\n        }, '');\n\n        expr = funcString + expr;\n\n        // Mitigate http://perfectionkills.com/global-eval-what-are-the-options/#new_function\n        if (!(/(['\"])use strict\\1/u).test(expr) &&\n            !keys.includes('arguments')\n        ) {\n            expr = 'var arguments = undefined;' + expr;\n        }\n\n        // Remove last semi so `return` will be inserted before\n        //  the previous one instead, allowing for the return\n        //  of a bare ending expression\n        expr = expr.replace(/;\\s*$/u, '');\n\n        // Insert `return`\n        const lastStatementEnd = expr.lastIndexOf(';');\n        const code = (lastStatementEnd > -1\n            ? expr.slice(0, lastStatementEnd + 1) +\n                ' return ' + expr.slice(lastStatementEnd + 1)\n            : ' return ' + expr);\n\n        // eslint-disable-next-line no-new-func\n        return (new Function(...keys, code))(...values);\n    }\n}\n\nJSONPath.prototype.vm = {\n    Script\n};\n\nJSONPath.prototype.safeVm = {\n    Script: SafeScript\n};\n\nexport {JSONPath};\n"],"names":["Hooks","name","callback","first","arguments","this","add","Array","isArray","forEach","env","call","context","Plugins","jsep","_classCallCheck","registered","_this","_len","length","plugins","_key","plugin","_typeof","init","Error","Jsep","expr","index","get","charAt","charCodeAt","message","error","description","node","hooks","run","value","find","ch","code","SPACE_CODE","TAB_CODE","LF_CODE","CR_CODE","runHook","nodes","gobbleExpressions","type","COMPOUND","body","untilICode","ch_i","SEMCOL_CODE","COMMA_CODE","gobbleExpression","push","throwError","searchHook","gobbleBinaryExpression","gobbleSpaces","to_check","substr","max_binop_len","tc_len","binary_ops","hasOwnProperty","isIdentifierStart","isIdentifierPart","biop","prec","stack","biop_info","left","right","i","cur_biop","prev","gobbleToken","gobbleBinaryOp","binaryPrecedence","right_a","right_associative","has","pop","BINARY_EXP","operator","isDecimalDigit","PERIOD_CODE","gobbleNumericLiteral","SQUOTE_CODE","DQUOTE_CODE","gobbleStringLiteral","OBRACK_CODE","gobbleArray","max_unop_len","unary_ops","argument","UNARY_EXP","prefix","gobbleIdentifier","literals","LITERAL","raw","this_str","THIS_EXP","OPAREN_CODE","gobbleGroup","gobbleTokenProperty","QUMARK_CODE","optional","MEMBER_EXP","computed","object","property","CBRACK_CODE","CALL_EXP","gobbleArguments","CPAREN_CODE","callee","chCode","number","parseFloat","str","startIndex","quote","closed","substring","start","IDENTIFIER","slice","termination","args","separator_count","String","fromCharCode","arg","SEQUENCE_EXP","expressions","ARRAY_EXP","elements","version","op_name","Math","max","precedence","isRightAssociative","char","additional_identifier_chars","literal_name","literal_value","getMaxKeyLen","parse","obj","concat","_toConsumableArray","Object","keys","map","k","op_val","assign","COLON_CODE","Set","true","false","null","getOwnPropertyNames","m","undefined","ternary","test","consequent","alternate","newTest","register","patternIndex","inCharSet","pattern","flags","RegExp","e","hasOwnProp","prototype","arr","item","unshift","NewError","_super","avoidNew","JSONPath","opts","otherTypeCallback","optObj","json","path","resultType","flatten","wrap","sandbox","preventEval","evalType","parent","parentProperty","TypeError","autostart","ret","evaluate","_this2","currParent","currParentProperty","currResultType","currPreventEval","currEvalType","currSandbox","currOtherTypeCallback","toPathString","exprList","toPathArray","shift","_hasParentSelector","result","_trace","filter","ea","isParentSelector","hasArrExpr","reduce","rslt","valOrPath","_getPreferredOutput","pointer","toPointer","_handleCallback","fullRetObj","preferredOutput","val","parentPropName","literalPriority","retObj","_this3","loc","x","addRet","elems","t","_walk","_slice","indexOf","safeLoc","replace","_eval","addType","valueType","includes","Number","isFinite","locProp","_step","_iterator","_createForOfIteratorHelper","split","s","n","done","part","err","f","rett","tmp","tl","tt","splice","len","parts","step","parseInt","end","min","_v","_vname","_$_parentProperty","_$_parent","_$_property","_$_root","_$_v","containsPath","_$_path","scriptCacheKey","cache","script","safeVm","Script","vm","runInNewContext","pathArr","p","toString","subx","$0","$1","prop","ups","join","exp","match","jsepRegex","SafeEval","eval","substitions","ast","evalAst","subs","evalBinaryExpression","evalCompound","evalConditionalExpression","evalIdentifier","evalLiteral","evalMemberExpression","evalUnaryExpression","evalArrayExpression","evalCallExpression","SyntaxError","a","b","last","ReferenceError","bind","el","apply","SafeScript","keyMap","funcs","source","target","conditionCb","il","moveToAnotherArray","key","values","vr","funcString","func","fString","lastStatementEnd","lastIndexOf","_construct","Function"],"mappings":"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"}